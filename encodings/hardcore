%STRATEGIA ANGOLI E PEDINE STABILI

%pedine negli angoli
pedinaAngolo(0,0).
pedinaAngolo(0,7).
pedinaAngolo(7,0).
pedinaAngolo(7,7).

%le pedinaStabile rappresentano la posizione di una pedina stabile e il peso annesso alla sua tipologia = tipo : peso    A : 2 , B : 4 , C : 8 , X : 16

%tipo A
pedinaStabile(2,0,2).
pedinaStabile(5,0,2).
pedinaStabile(0,2,2).
pedinaStabile(0,5,2).
pedinaStabile(2,7,2).
pedinaStabile(5,7,2).
pedinaStabile(7,2,2).
pedinaStabile(7,5,2).

%tipo B
pedinaStabile(3,0,4).
pedinaStabile(4,0,4).
pedinaStabile(0,3,4).
pedinaStabile(0,4,4).
pedinaStabile(3,7,4).
pedinaStabile(4,7,4).
pedinaStabile(7,3,4).
pedinaStabile(7,4,4).

%tipo C
pedinaStabile(1,0,8).
pedinaStabile(6,0,8).
pedinaStabile(0,1,8).
pedinaStabile(0,6,8).
pedinaStabile(1,7,8).
pedinaStabile(6,7,8).
pedinaStabile(7,1,8).
pedinaStabile(7,6,8).

%tipo X
pedinaStabile(1,1,16).
pedinaStabile(1,6,16).
pedinaStabile(6,1,16).
pedinaStabile(6,6,16).

% Optimize se c'e' un angolo da poter scegliere e lui non lo sceglie
:~ posizioneNonScelta(Riga, Colonna), pedinaAngolo(Riga, Colonna). [1:15]

% Optimize se lui sceglie una posizione "pessima"
:~ posizioneScelta(Riga, Colonna), pedinaStabile(Riga, Colonna, Peso). [Peso : 4]


%GUESS AND CHECK

% il numero di righe e di colonne della matrice
rigaOcolonna(0..7).

% posizioni gia' presenti delle pedine nella matrice
pedinaPresente(Riga, Colonna, Valore) :- cell(Riga, Colonna, Valore), Valore != 0, Valore != 3.

% posizioni occupate
posizioneOccupata(Riga, Colonna) :- pedinaPresente(Riga, Colonna, _).

% posizioni non occupate
posizioneNonOccupata(Riga, Colonna) :- not posizioneOccupata(Riga,Colonna), rigaOcolonna(Riga), rigaOcolonna(Colonna).

% colore pedina del computer
coloreComputer(1).

% colore pedina del'avversario
coloreAvversario(2).

% mosse valide
mossaValida(X,Y) :- cell(X,Y,3).

% Guess posizioneScelta indica la posizione scelta dal computer, posizione non scelta tutte le altre possibili
posizioneScelta(X,Y) | posizioneNonScelta(X,Y) :- mossaValida(X,Y).

% Check ci deve essere un solo atomo ground di posizioneScelta
:- not #count{X,Y: posizioneScelta(X,Y)}=1.

% Output
answer(X,Y) :- posizioneScelta(X,Y).



% BUCO

%controlla se c'è un buco tra le pedine la prima e' sempre quella dove dovra' essere inserita la pedina e la seconda e' sempre una gia' del computer

bucoPerRigaP(Riga, Colonna1, Colonna2) :- pedinaPresente(Riga, Colonna2, C), coloreComputer(C), posizioneNonOccupata(Riga,Colonna3), Colonna3 > Colonna1, Colonna3 < Colonna2, rigaOcolonna(Colonna1).
bucoPerRigaD(Riga, Colonna1, Colonna2) :- pedinaPresente(Riga, Colonna2, C), coloreComputer(C), posizioneNonOccupata(Riga,Colonna3), Colonna3 < Colonna1, Colonna3 > Colonna2, rigaOcolonna(Colonna1).

bucoPerColonnaP(Colonna, Riga1, Riga2) :- pedinaPresente(Riga2, Colonna, C), coloreComputer(C), posizioneNonOccupata(Riga3,Colonna), Riga3 > Riga1, Riga3 < Riga2, rigaOcolonna(Riga1).
bucoPerColonnaD(Colonna, Riga1, Riga2) :- pedinaPresente(Riga2, Colonna, C), coloreComputer(C), posizioneNonOccupata(Riga3,Colonna), Riga3 < Riga1, Riga3 > Riga2, rigaOcolonna(Riga1).

% secondo punto in alto a sinistra del primo punto
bucoPerDiagonaleAS(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), posizioneNonOccupata(Riga3,Colonna3), Riga1 = Riga3 + K1, Colonna1 = Colonna3 + K1, Riga2 = Riga3 - K2, Colonna2 = Colonna3 - K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).
% secondo punto in alto a destra del primo punto
bucoPerDiagonaleAD(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), posizioneNonOccupata(Riga3,Colonna3), Riga1 = Riga3 + K1, Colonna1 = Colonna3 - K1, Riga2 = Riga3 - K2, Colonna2 = Colonna3 + K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).
% secondo punto in basso a sinistra del primo punto
bucoPerDiagonaleBS(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), posizioneNonOccupata(Riga3,Colonna3), Riga1 = Riga3 - K1, Colonna1 = Colonna3 + K1, Riga2 = Riga3 + K2, Colonna2 = Colonna3 - K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).
% secondo punto in basso a destra del primo punto
bucoPerDiagonaleBD(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), posizioneNonOccupata(Riga3,Colonna3), Riga1 = Riga3 - K1, Colonna1 = Colonna3 - K1, Riga2 = Riga3 + K2, Colonna2 = Colonna3 + K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).



% STRATEGIA ANGOLI E STABILI

rigaConPedina(R) :- pedinaPresente(R, _, _).
colonnaConPedina(C) :- pedinaPresente(_, C, _).
rigaSenzaPedine(R) :- rigaOcolonna(R), not rigaConPedina(R).
colonnaSenzaPedine(C) :- rigaOcolonna(C), not colonnaConPedina(C).

%conta quanti avversari ci sono sulla riga 1 e 8
contaAvversariRiga(Quanti, 0):- #count{C : pedinaPresente(0, C, Ca), coloreAvversario(Ca)} = Quanti, rigaOcolonna(Quanti).
contaAvversariRiga(Quanti, 7):- #count{C : pedinaPresente(7, C, Ca), coloreAvversario(Ca)} = Quanti, rigaOcolonna(Quanti).

%conta quanti avversari ci sono sulla colonna 1 e 8
contaAvversariColonna(Quanti, 0):- #count{R : pedinaPresente(R, 0, Ca), coloreAvversario(Ca)} = Quanti, rigaOcolonna(Quanti).
contaAvversariColonna(Quanti, 7):- #count{R : pedinaPresente(R, 7, Ca), coloreAvversario(Ca)} = Quanti, rigaOcolonna(Quanti).


% se la posizioneScelta e' sul bordo (e' sulla prima/ultima riga/colonna)
posizioneSceltaSulBordo :- posizioneScelta(0, Colonna).
posizioneSceltaSulBordo :- posizioneScelta(7, Colonna).
posizioneSceltaSulBordo :- posizioneScelta(Riga, 0).
posizioneSceltaSulBordo :- posizioneScelta(Riga, 7).


% se c'e' un angolo da poter scegliere e lui non lo sceglie
:~ posizioneNonScelta(Riga, Colonna), pedinaAngolo(Riga, Colonna). [1 : 15]


% se lui sceglie una posizione che mangia anche una pedina in posizione X oppure sceglie la posizione X e l'angolo non e' stato ancora preso
:~ posizioneScelta(Riga, Colonna), traSullaStessaRiga(Riga, Colonna, Colonna2, ColonnaR), pedinaPresente(Riga, Colonna2, C), coloreComputer(C), pedinaStabile(Riga, ColonnaR, 16), pedinaAngoloDiQuestaX(Riga, ColonnaR, RigaA, ColonnaA), posizioneNonOccupata(RigaA, ColonnaA). [4 : 13]
:~ posizioneScelta(Riga, Colonna), traSullaStessaColonna(Riga, Riga2, Colonna, RigaR), pedinaPresente(Riga2, Colonna, C), coloreComputer(C), pedinaStabile(RigaR, Colonna, 16), pedinaAngoloDiQuestaX(RigaR, Colonna, RigaA, ColonnaA), posizioneNonOccupata(RigaA, ColonnaA). [4 : 13]
:~ posizioneScelta(Riga, Colonna), traSullaStessaDiagonale(Riga, Colonna, Riga2, Colonna2, RigaR, ColonnaR), pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), pedinaStabile(RigaR, ColonnaR, 16), pedinaAngoloDiQuestaX(RigaR, ColonnaR, RigaA, ColonnaA), posizioneNonOccupata(RigaA, ColonnaA). [4 : 13]
:~ posizioneScelta(Riga, Colonna), pedinaStabile(Riga, Colonna, 16), pedinaAngoloDiQuestaX(Riga, Colonna, RigaA, ColonnaA), posizioneNonOccupata(RigaA, ColonnaA). [4 : 13]


pedinaAngoloDiQuestaX(2, 2, 0, 0).
pedinaAngoloDiQuestaX(2, 7, 0, 7).
pedinaAngoloDiQuestaX(7, 2, 7, 0).
pedinaAngoloDiQuestaX(7, 7, 7, 7).



% se lui può mangiare tutto su una riga /colonna pari a 1/8 e non lo fa , 
% ha priorità maggiore rispetto al mettere una prima pedina sul bordo perchè deve mangiare altrimenti verrà mangiato
% mangia_tutte_sul_bordo :- posizioneScelta(1, Colonna), contaAvversariRiga(QuantiAvv, 1), quanti_ne_mangia_riga(QuantiMangiati), QuantiMangiati = QuantiAvv.
% mangia_tutte_sul_bordo :- posizioneScelta(8, Colonna), contaAvversariRiga(QuantiAvv, 8), quanti_ne_mangia_riga(QuantiMangiati),  QuantiMangiati = QuantiAvv.
% mangia_tutte_sul_bordo :- posizioneScelta(Riga, 1), contaAvversariColonna(QuantiAvv, 1), quanti_ne_mangia_colonna(QuantiMangiati), QuantiMangiati = QuantiAvv.
% mangia_tutte_sul_bordo :- posizioneScelta(Riga, 8), contaAvversariColonna(QuantiAvv, 8), quanti_ne_mangia_colonna(QuantiMangiati), QuantiMangiati = QuantiAvv.
:~ posizioneScelta(Riga, Colonna), Riga <> 0, Riga <> 7, Colonna <> 0, Colonna <> 7. [1 : 12]
:~ posizioneScelta(0, Colonna), contaAvversariRiga(QuantiAvv, 0), quanti_ne_mangia_riga(QuantiMangiati), QuantiMangiati > 0, QuantiMangiati <> QuantiAvv. [2 : 12]
:~ posizioneScelta(7, Colonna), contaAvversariRiga(QuantiAvv, 7), quanti_ne_mangia_riga(QuantiMangiati), QuantiMangiati > 0, QuantiMangiati <> QuantiAvv. [2 : 12]
:~ posizioneScelta(Riga, 0), contaAvversariColonna(QuantiAvv, 0), quanti_ne_mangia_colonna(QuantiMangiati), QuantiMangiati > 0, QuantiMangiati <> QuantiAvv. [2 : 12]
:~ posizioneScelta(Riga, 7), contaAvversariColonna(QuantiAvv, 7), quanti_ne_mangia_colonna(QuantiMangiati), QuantiMangiati > 0, QuantiMangiati <> QuantiAvv. [2 : 12]
:~ posizioneScelta(0, Colonna), contaAvversariRiga(QuantiAvv, 0), quanti_ne_mangia_riga(QuantiMangiati), QuantiMangiati = 0, QuantiAvv > 0. [2 : 12]
:~ posizioneScelta(7, Colonna), contaAvversariRiga(QuantiAvv, 7), quanti_ne_mangia_riga(QuantiMangiati), QuantiMangiati = 0, QuantiAvv > 0. [2 : 12]
:~ posizioneScelta(Riga, 0), contaAvversariColonna(QuantiAvv, 0), quanti_ne_mangia_colonna(QuantiMangiati), QuantiMangiati = 0, QuantiAvv > 0. [2 : 12]
:~ posizioneScelta(Riga, 7), contaAvversariColonna(QuantiAvv, 7), quanti_ne_mangia_colonna(QuantiMangiati), QuantiMangiati = 0, QuantiAvv > 0. [2 : 12]
:~ posizioneScelta(Riga, 0), contaAvversariColonna(0, 0). [1 : 12]
:~ posizioneScelta(Riga, 7), contaAvversariColonna(0, 7). [1 : 12]
:~ posizioneScelta(0, Colonna), contaAvversariRiga(0, 0). [1 : 12]
:~ posizioneScelta(7, Colonna), contaAvversariRiga(0, 7). [1 : 12]


% se lui vuole mettere in una posizione ad un bordo ma lascia un buco
:~ posizioneScelta(Riga, 0), Riga2 = Riga + 2, pedinaPresente(Riga2, 0, C), coloreComputer(C), Riga1 = Riga + 1, posizioneNonOccupata(Riga1, 0). [2 : 10]
:~ posizioneScelta(Riga, 0), Riga = Riga2 + 2, pedinaPresente(Riga2, 0, C), coloreComputer(C), Riga = Riga1 + 1, posizioneNonOccupata(Riga1, 0). [2 : 10]
:~ posizioneScelta(Riga, 7), Riga2 = Riga + 2, pedinaPresente(Riga2, 7, C), coloreComputer(C), Riga1 = Riga + 1, posizioneNonOccupata(Riga1, 7). [2 : 10]
:~ posizioneScelta(Riga, 7), Riga = Riga2 + 2, pedinaPresente(Riga2, 7, C), coloreComputer(C), Riga = Riga1 + 1, posizioneNonOccupata(Riga1, 7). [2 : 10]
:~ posizioneScelta(0, Colonna), Colonna2 = Colonna + 2, pedinaPresente(0, Colonna2, C), coloreComputer(C), Colonna1 = Colonna + 1, posizioneNonOccupata(0, Colonna1). [2 : 10]
:~ posizioneScelta(0, Colonna), Colonna = Colonna2 + 2, pedinaPresente(0, Colonna2, C), coloreComputer(C), Colonna = Colonna1 + 1, posizioneNonOccupata(0, Colonna1). [2 : 10]
:~ posizioneScelta(7, Colonna), Colonna2 = Colonna + 2, pedinaPresente(7, Colonna2, C), coloreComputer(C), Colonna1 = Colonna + 1, posizioneNonOccupata(7, Colonna1). [2 : 10]
:~ posizioneScelta(7, Colonna), Colonna = Colonna2 + 2, pedinaPresente(7, Colonna2, C), coloreComputer(C), Colonna = Colonna1 + 1, posizioneNonOccupata(7, Colonna1). [2 : 10]


% se lui può mettere in una posizione ad un bordo e non ci sono pedine in quel bordo
:~ posizioneNonScelta(_, 0), colonnaSenzaPedine(0). [1 : 10]
:~ posizioneNonScelta(_, 7), colonnaSenzaPedine(7). [1 : 10]
:~ posizioneNonScelta(0, _), rigaSenzaPedine(0). [1 : 10]
:~ posizioneNonScelta(7, _), rigaSenzaPedine(7). [1 : 10]


% se lui può mettere in una posizione ad un bordo e non ci sono pedine in quel bordo vicino a lui (che quindi lo possono mangiare)
:~ posizioneNonScelta(Riga, 0), RigaB = Riga + 1, nonPedinaAvversario(RigaB, 0), Riga = RigaA + 1, nonPedinaAvversario(RigaA, 0). [1 : 6]
:~ posizioneNonScelta(Riga, 7), RigaB = Riga + 1, nonPedinaAvversario(RigaB, 7), Riga = RigaA + 1, nonPedinaAvversario(RigaA, 7). [1 : 6]
:~ posizioneNonScelta(0, Colonna), ColonnaD = Colonna + 1, nonPedinaAvversario(0, ColonnaD), Colonna = ColonnaS + 1, nonPedinaAvversario(0, ColonnaS). [1 : 6]
:~ posizioneNonScelta(7, Colonna), ColonnaD = Colonna + 1, nonPedinaAvversario(7, ColonnaD), Colonna = ColonnaS + 1, nonPedinaAvversario(7, ColonnaS). [1 : 6]

nonPedinaAvversario(Riga, Colonna) :- posizioneNonOccupata(Riga, Colonna).
nonPedinaAvversario(Riga, Colonna) :- pedinaPresente(Riga, Colonna, C), coloreComputer(C).


% se lui può mettere in una posizione ad un bordo ed in quel bordo sia subito alla sua sinistra che subito alla sua destra c'è' l'avversario
:~ posizioneNonScelta(Riga, 0), RigaB = Riga + 1, pedinaPresente(RigaB, 0, Ca), Riga = RigaA + 1, pedinaPresente(RigaA, 0, Ca), coloreAvversario(Ca). [1 : 6]
:~ posizioneNonScelta(Riga, 7), RigaB = Riga + 1, pedinaPresente(RigaB, 7, Ca), Riga = RigaA + 1, pedinaPresente(RigaA, 7, Ca), coloreAvversario(Ca). [1 : 6]
:~ posizioneNonScelta(0, Colonna), ColonnaD = Colonna + 1, pedinaPresente(0, ColonnaD, Ca), Colonna = ColonnaS + 1, pedinaPresente(0, ColonnaS, Ca), coloreAvversario(Ca). [1 : 6]
:~ posizioneNonScelta(7, Colonna), ColonnaD = Colonna + 1, pedinaPresente(7, ColonnaD, Ca), Colonna = ColonnaS + 1, pedinaPresente(7, ColonnaS, Ca), coloreAvversario(Ca). [1 : 6]


% se lui sceglie una posizione "pessima"
:~ posizioneScelta(Riga, Colonna), pedinaStabile(Riga, Colonna, Peso), Peso <> 16. [Peso : 4]


% se non ci sono pedine in un bordo lui non deve mettere nelle celle subito prima del bordo
% perche' altrimenti permetterebbe all'avversario di mettere per primo una pedina sul bordo
:~ colonnaSenzaPedine(1), posizioneScelta(_, 1). [1 : 4]
:~ colonnaSenzaPedine(8), posizioneScelta(_, 6). [1 : 4]
:~ rigaSenzaPedine(1), posizioneScelta(1, _). [1 : 4]
:~ rigaSenzaPedine(8), posizioneScelta(6, _). [1 : 4]



% STRATEGIA QUANTI NE MANGIA

% se c'e' tra due pedine una pedina non "mangiabile" (una del computer o una cella vuota)

pedinaNonMangiabilePerRigaP(Riga, Colonna1, Colonna2) :- bucoPerRigaP(Riga, Colonna1, Colonna2).
pedinaNonMangiabilePerRigaP(Riga, Colonna1, Colonna2) :- pedinaPresente(Riga, Colonna2, C), coloreComputer(C), pedinaPresente(Riga, Colonna3, C), Colonna3 > Colonna1, Colonna3 < Colonna2, rigaOcolonna(Colonna1).

pedinaNonMangiabilePerRigaD(Riga, Colonna1, Colonna2) :- bucoPerRigaD(Riga, Colonna1, Colonna2).
pedinaNonMangiabilePerRigaD(Riga, Colonna1, Colonna2) :- pedinaPresente(Riga, Colonna2, C), coloreComputer(C), pedinaPresente(Riga, Colonna3, C), Colonna3 < Colonna1, Colonna3 > Colonna2, rigaOcolonna(Colonna1).


pedinaNonMangiabilePerColonnaP(Colonna, Riga1, Riga2) :- bucoPerColonnaP(Colonna, Riga1, Riga2).
pedinaNonMangiabilePerColonnaP(Colonna, Riga1, Riga2) :- pedinaPresente(Riga2, Colonna, C), coloreComputer(C), pedinaPresente(Riga3, Colonna, C), Riga3 > Riga1, Riga3 < Riga2, rigaOcolonna(Riga1).

pedinaNonMangiabilePerColonnaD(Colonna, Riga1, Riga2) :- bucoPerColonnaD(Colonna, Riga1, Riga2).
pedinaNonMangiabilePerColonnaD(Colonna, Riga1, Riga2) :- pedinaPresente(Riga2, Colonna, C), coloreComputer(C), pedinaPresente(Riga3, Colonna, C), Riga3 < Riga1, Riga3 > Riga2, rigaOcolonna(Riga1).


% secondo punto in alto a sinistra del primo punto
pedinaNonMangiabilePerDiagonaleAS(Riga1, Colonna1, Riga2, Colonna2) :- bucoPerDiagonaleAS(Riga1, Colonna1, Riga2, Colonna2).
pedinaNonMangiabilePerDiagonaleAS(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), pedinaPresente(Riga3, Colonna3, C), Riga1 = Riga3 + K1, Colonna1 = Colonna3 + K1, Riga2 = Riga3 - K2, Colonna2 = Colonna3 - K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).
% secondo punto in alto a destra del primo punto
pedinaNonMangiabilePerDiagonaleAD(Riga1, Colonna1, Riga2, Colonna2) :- bucoPerDiagonaleAD(Riga1, Colonna1, Riga2, Colonna2).
pedinaNonMangiabilePerDiagonaleAD(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), pedinaPresente(Riga3, Colonna3, C), Riga1 = Riga3 + K1, Colonna1 = Colonna3 - K1, Riga2 = Riga3 - K2, Colonna2 = Colonna3 + K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).
% secondo punto in basso a sinistra del primo punto
pedinaNonMangiabilePerDiagonaleBS(Riga1, Colonna1, Riga2, Colonna2) :- bucoPerDiagonaleBS(Riga1, Colonna1, Riga2, Colonna2).
pedinaNonMangiabilePerDiagonaleBS(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), pedinaPresente(Riga3, Colonna3, C), Riga1 = Riga3 - K1, Colonna1 = Colonna3 + K1, Riga2 = Riga3 + K2, Colonna2 = Colonna3 - K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).
% secondo punto in basso a destra del primo punto
pedinaNonMangiabilePerDiagonaleBD(Riga1, Colonna1, Riga2, Colonna2) :- bucoPerDiagonaleBD(Riga1, Colonna1, Riga2, Colonna2).
pedinaNonMangiabilePerDiagonaleBD(Riga1, Colonna1, Riga2, Colonna2) :- pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), pedinaPresente(Riga3, Colonna3, C), Riga1 = Riga3 - K1, Colonna1 = Colonna3 - K1, Riga2 = Riga3 + K2, Colonna2 = Colonna3 + K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1).



% in 1 c'e' la posizione scelta in 2 c'è una pedina del computer in Colonna c'e' la colonna di una pedina della stessa Riga, compresa tra 1 e 2
traSullaStessaRiga(Riga, Colonna1, Colonna2, Colonna) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga, Colonna1), pedinaPresente(Riga, Colonna2, C), coloreComputer(C), Colonna > Colonna1, Colonna < Colonna2, not pedinaNonMangiabilePerRigaP(Riga, Colonna1, Colonna2).
traSullaStessaRiga(Riga, Colonna1, Colonna2, Colonna) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga, Colonna1), pedinaPresente(Riga, Colonna2, C), coloreComputer(C), Colonna < Colonna1, Colonna > Colonna2, not pedinaNonMangiabilePerRigaD(Riga, Colonna1, Colonna2).

% in 1 c'e' la posizione scelta in 2 c'è una pedina del computer in Riga c'e' la colonna di una pedina della stessa Colonna, compresa tra 1 e 2
traSullaStessaColonna(Riga1, Riga2, Colonna, Riga) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga1, Colonna), pedinaPresente(Riga2, Colonna, C), coloreComputer(C), Riga > Riga1, Riga < Riga2, not pedinaNonMangiabilePerColonnaP(Colonna, Riga1, Riga2).
traSullaStessaColonna(Riga1, Riga2, Colonna, Riga) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga1, Colonna), pedinaPresente(Riga2, Colonna, C), coloreComputer(C), Riga < Riga1, Riga > Riga2, not pedinaNonMangiabilePerColonnaD(Colonna, Riga1, Riga2).

% secondo punto in alto a sinistra del primo punto
traSullaStessaDiagonale(Riga1, Colonna1, Riga2, Colonna2, Riga, Colonna) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga1, Colonna1), pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), Riga1 = Riga + K1, Colonna1 = Colonna + K1, Riga2 = Riga - K2, Colonna2 = Colonna - K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1), not pedinaNonMangiabilePerDiagonaleAS(Riga1, Colonna1, Riga2, Colonna2).
% secondo punto in alto a destra del primo punto
traSullaStessaDiagonale(Riga1, Colonna1, Riga2, Colonna2, Riga, Colonna) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga1, Colonna1), pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), Riga1 = Riga + K1, Colonna1 = Colonna - K1, Riga2 = Riga - K2, Colonna2 = Colonna + K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1), not pedinaNonMangiabilePerDiagonaleAD(Riga1, Colonna1, Riga2, Colonna2).
% secondo punto in basso a sinistra del primo punto
traSullaStessaDiagonale(Riga1, Colonna1, Riga2, Colonna2, Riga, Colonna) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga1, Colonna1), pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), Riga1 = Riga - K1, Colonna1 = Colonna + K1, Riga2 = Riga + K2, Colonna2 = Colonna - K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1), not pedinaNonMangiabilePerDiagonaleBS(Riga1, Colonna1, Riga2, Colonna2).
% secondo punto in basso a destra del primo punto
traSullaStessaDiagonale(Riga1, Colonna1, Riga2, Colonna2, Riga, Colonna) :- pedinaPresente(Riga, Colonna, Ca), coloreAvversario(Ca), posizioneScelta(Riga1, Colonna1), pedinaPresente(Riga2, Colonna2, C), coloreComputer(C), Riga1 = Riga - K1, Colonna1 = Colonna - K1, Riga2 = Riga + K2, Colonna2 = Colonna + K2, rigaOcolonna(K1), rigaOcolonna(K2), rigaOcolonna(Riga1), rigaOcolonna(Colonna1), not pedinaNonMangiabilePerDiagonaleBD(Riga1, Colonna1, Riga2, Colonna2).



% conto quanti ne mangia ci dovrebbe essere una sola istanza per ogni regola
possibile_valore(0..64).
quanti_ne_mangia_riga(Quanti) :- posizioneScelta(Riga, Colonna), #count{ ColonnaR : traSullaStessaRiga(Riga, Colonna, Colonna2, ColonnaR), pedinaPresente(Riga, Colonna2, C), coloreComputer(C) } = Quanti, possibile_valore(Quanti).
quanti_ne_mangia_colonna(Quanti) :- posizioneScelta(Riga, Colonna), #count{ RigaR : traSullaStessaColonna(Riga, Riga2, Colonna, RigaR), pedinaPresente(Riga2, Colonna, C), coloreComputer(C) } = Quanti, possibile_valore(Quanti).
quanti_ne_mangia_diagonale(Quanti) :- posizioneScelta(Riga, Colonna), #count{ RigaR, ColonnaR : traSullaStessaDiagonale(Riga, Colonna, Riga2, Colonna2, RigaR, ColonnaR), pedinaPresente(Riga2, Colonna2, C), coloreComputer(C) } = Quanti, possibile_valore(Quanti).

quanti_ne_mangia(Quanti) :- quanti_ne_mangia_riga(QuantiRiga), quanti_ne_mangia_colonna(QuantiColonna), quanti_ne_mangia_diagonale(QuantiDiagonale), QuantiRigaColonna = QuantiRiga + QuantiColonna, Quanti = QuantiRigaColonna + QuantiDiagonale, possibile_valore(Quanti), possibile_valore(QuantiRigaColonna).

:~ quanti_ne_mangia(Quanti), 64 = Q + Quanti, possibile_valore(Q). [Q : 2]



%STRATEGIA PEDINE DI FRONTIERA E MURI

% se in (Riga, Colonna) c'e' una pedina di frontiera del computer
% pedinaDiFrontieraComputer(Riga, Colonna) :- pedinaPresente(Riga, Colonna, C), coloreComputer(C), vicinaAlVuoto(Riga, Colonna).


% se una pedina ha nelle 9 a lei adiacenti una posizioneNonOccupata
% alto-sinistra
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga2, Colonna2), Riga = Riga2 + 1, Colonna = Colonna2 + 1.
% alto-centro
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga2, Colonna), Riga = Riga2 + 1.
% alto-destra
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga2, Colonna2), Riga = Riga2 + 1, Colonna2 = Colonna + 1.
% centro-sinistra
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga, Colonna2), Colonna = Colonna2 + 1.
% centro-destra
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga, Colonna2), Colonna2 = Colonna + 1.
% basso-sinistra
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga2, Colonna2), Riga2 = Riga + 1, Colonna = Colonna2 + 1.
% basso-centro
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga2, Colonna), Riga2 = Riga + 1.
% basso-destra
% vicinaAlVuoto(Riga, Colonna) :- posizioneOccupata(Riga, Colonna), posizioneNonOccupata(Riga2, Colonna2), Riga2 = Riga + 1, Colonna2 = Colonna + 1.


% le pedine "mangiate" nella mossa corrente con pedinaScelta
pedinaGirataConMossaCorrente(Riga, ColonnaR) :- posizioneScelta(Riga, Colonna), traSullaStessaRiga(Riga, Colonna, Colonna2, ColonnaR), pedinaPresente(Riga, Colonna2, C), coloreComputer(C).
pedinaGirataConMossaCorrente(RigaR, Colonna) :- posizioneScelta(Riga, Colonna), traSullaStessaColonna(Riga, Riga2, Colonna, RigaR), pedinaPresente(Riga2, Colonna, C), coloreComputer(C).
pedinaGirataConMossaCorrente(RigaR, ColonnaR) :- posizioneScelta(Riga, Colonna), traSullaStessaDiagonale(Riga, Colonna, Riga2, Colonna2, RigaR, ColonnaR), pedinaPresente(Riga2, Colonna2, C), coloreComputer(C).


% se una pedinaGirataConMossaCorrente e' una pedina di frontiera
pedinaDiFrontieraComputerDopoMossaCorrente(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), vicinaAlVuoto(Riga, Colonna).


% se una pedina ha nelle 9 a lei adiacenti una posizioneNonOccupata
% alto-sinistra
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga2, Colonna2), posizioneNonOccupata(Riga2, Colonna2), Riga = Riga2 + 1, Colonna = Colonna2 + 1.
% alto-centro
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga2, Colonna), posizioneNonOccupata(Riga2, Colonna), Riga = Riga2 + 1.
% alto-destra
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga2, Colonna2), posizioneNonOccupata(Riga2, Colonna2), Riga = Riga2 + 1, Colonna2 = Colonna + 1.
% centro-sinistra
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga, Colonna2), posizioneNonOccupata(Riga, Colonna2), Colonna = Colonna2 + 1.
% centro-destra
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga, Colonna2), posizioneNonOccupata(Riga, Colonna2), Colonna2 = Colonna + 1.
% basso-sinistra
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga2, Colonna2), posizioneNonOccupata(Riga2, Colonna2), Riga2 = Riga + 1, Colonna = Colonna2 + 1.
% basso-centro
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga2, Colonna), posizioneNonOccupata(Riga2, Colonna), Riga2 = Riga + 1.
% basso-destra
vicinaAlVuoto(Riga, Colonna) :- pedinaGirataConMossaCorrente(Riga, Colonna), not pedinaGirataConMossaCorrente(Riga2, Colonna2), posizioneNonOccupata(Riga2, Colonna2), Riga2 = Riga + 1, Colonna2 = Colonna + 1.


:~ pedinaDiFrontieraComputerDopoMossaCorrente(Riga, Colonna). [1 : 3]